#!/usr/bin/env python3
"""
Stage 8: build_snes_rom.py
Assembles all translated .asm files into a final SNES LoROM .sfc using ca65/ld65.
Embeds CHR data, computes SNES checksum, and writes the build report.

Output: output/output.sfc, output/build_report.json
"""
import argparse
import json
import struct
import subprocess
import sys
import time
from pathlib import Path

SNES_HEADER_OFFSET_LOROM = 0x7FC0   # LoROM: internal header title starts at $7FC0
SNES_CHECKSUM_OFFSET     = 0x7FDC   # complement ($7FDC–$7FDD), checksum ($7FDE–$7FDF)

# SNES ROM type codes (FFCC)
ROM_TYPE_ROM_ONLY = 0x00
ROM_TYPE_ROM_SRAM = 0x02

# Country code: USA NTSC = $01
COUNTRY_NTSC = 0x01


def find_tool(name: str) -> str | None:
    """Find a CLI tool via 'which'."""
    result = subprocess.run(["which", name], capture_output=True, text=True)
    return result.stdout.strip() if result.returncode == 0 else None


def check_toolchain():
    ca65 = find_tool("ca65")
    ld65 = find_tool("ld65")
    if not ca65 or not ld65:
        print("ERROR: ca65/ld65 not found. Install with: brew install cc65", file=sys.stderr)
        sys.exit(1)
    return ca65, ld65


def generate_master_asm(workspace: Path, bank_layout: dict) -> Path:
    """Generate master.asm that .includes all translated bank files."""
    translated_dir = workspace / "translated"
    bank_files = sorted(translated_dir.glob("bank_*_65816.asm"))

    lines = [
        "; master.asm — auto-generated by build_snes_rom.py",
        ".setcpu \"65816\"",
        ".smart",
        "",
        '; System bank: PPU wrappers, mapper stubs, PPU init, SNES header',
        '.segment "BANK00"',
        '    .include "ppu_init.asm"',
        '    .include "ppu_wrappers.asm"',
        '    .include "mapper_stubs.asm"',
        "",
        "; --- Interrupt vector trampolines ---",
        "; SNES vectors must hold 16-bit addresses in bank $00.",
        "; These stubs live in BANK00 and JML (long-jump) to the actual handlers",
        "; which may be in any translated bank.",
        "NMI_TRAMPOLINE:",
        "    JML NMI_HANDLER",
        "IRQ_TRAMPOLINE:",
        "    JML IRQ_HANDLER",
        "RESET_TRAMPOLINE:",
        "    JML RESET_HANDLER",
        "",
    ]

    # Include translated PRG banks
    for bank_info in bank_layout.get("bank_map", []):
        snes_bank_int = int(bank_info["snes_bank"], 16)
        nes_bank = bank_info["nes_bank_num"]
        bank_file = f"bank_{nes_bank:02d}_65816.asm"
        seg_name = f"BANK{snes_bank_int:02X}"

        lines += [
            f'; Translated NES PRG bank {nes_bank} → SNES bank ${snes_bank_int:02X}',
            f'.segment "{seg_name}"',
            f'    .include "translated/{bank_file}"',
            "",
        ]

    # Audio stub (placeholder — SPC700 code assembled separately)
    audio_bank_int = int(bank_layout.get("audio_bank", "0x1E"), 16)
    audio_seg = f"BANK{audio_bank_int:02X}"
    lines += [
        '; SPC700 audio driver stub',
        f'.segment "{audio_seg}"',
        '    .res 512, $00',
        "",
    ]

    # SNES interrupt vectors (LoROM: bank $00, $FFxx)
    # Vectors must be 16-bit addresses within bank $00.
    # NMI_TRAMPOLINE / IRQ_TRAMPOLINE / RESET_TRAMPOLINE are defined above in BANK00
    # and use JML to reach the actual handlers in any translated bank.
    lines += [
        '; SNES interrupt vectors',
        '.segment "VECTORS"',
        ".org $00FFE4",
        '    .word $0000              ; COP (native)',
        '    .word $0000              ; BRK (native)',
        '    .word $0000              ; ABORT (native)',
        '    .word NMI_TRAMPOLINE     ; NMI (native)',
        '    .word $0000              ; (unused in native mode)',
        '    .word IRQ_TRAMPOLINE     ; IRQ (native)',
        '.org $00FFF4',
        '    .word $0000              ; COP (emulation)',
        '    .word $0000              ; (unused)',
        '    .word $0000              ; ABORT (emulation)',
        '    .word NMI_TRAMPOLINE     ; NMI (emulation)',
        '    .word RESET_TRAMPOLINE   ; RESET',
        '    .word IRQ_TRAMPOLINE     ; IRQ/BRK (emulation)',
        "",
        "; Fallback stubs — only assembled if translated code did not define the label.",
        "; The trampolines above JML to these, so they must always be present.",
        ".ifndef NMI_HANDLER",
        "NMI_HANDLER:",
        "    RTI",
        ".endif",
        ".ifndef IRQ_HANDLER",
        "IRQ_HANDLER:",
        "    RTI",
        ".endif",
        ".ifndef RESET_HANDLER",
        "RESET_HANDLER:",
        "    JSR SNES_PPU_INIT",
        "    BRA *",
        ".endif",
    ]

    master_path = workspace / "master.asm"
    master_path.write_text("\n".join(lines))
    return master_path


def generate_lorom_cfg(workspace: Path, bank_layout: dict) -> Path:
    """Generate ld65 LoROM linker configuration."""
    segments = []
    bank_map = bank_layout.get("bank_map", [])

    # Add system + translated banks
    all_banks = [{"snes_bank": "0x00", "seg": "BANK00", "start": 0x008000, "size": 0x8000}]
    for bi in bank_map:
        n = int(bi["snes_bank"], 16)
        seg = f"BANK{n:02X}"
        start = n * 0x10000 + 0x8000
        all_banks.append({"snes_bank": bi["snes_bank"], "seg": seg, "start": start, "size": 0x8000})

    # Audio bank
    audio_bank_int = int(bank_layout.get("audio_bank", "0x1E"), 16)
    all_banks.append({
        "snes_bank": f"0x{audio_bank_int:02X}",
        "seg": f"BANK{audio_bank_int:02X}",
        "start": audio_bank_int * 0x10000 + 0x8000,
        "size": 0x8000,
    })

    # Vectors in bank $00 at $FFxx
    all_banks.append({
        "snes_bank": "0x00",
        "seg": "VECTORS",
        "start": 0x00FFE0,
        "size": 0x20,
    })

    memory_lines = ["MEMORY {"]
    # ZEROPAGE maps to SNES Direct Page (WRAM at $0000–$00FF, not in ROM file)
    memory_lines.append("    ZEROPAGE: start = $0000, size = $0100, type = rw, define = yes;")
    seg_lines    = ["SEGMENTS {"]
    seg_lines.append("    ZEROPAGE: load = ZEROPAGE, type = zp;")

    for b in all_banks:
        seg = b["seg"]
        start = b["start"]
        size = b["size"]
        memory_lines.append(
            f"    {seg}: start = ${start:06X}, size = ${size:04X}, "
            f"fill = yes, fillval = $FF, file = %O;"
        )
        seg_lines.append(f"    {seg}: load = {seg}, type = ro;")

    memory_lines.append("}")
    seg_lines.append("}")

    cfg_text = "\n".join(memory_lines) + "\n\n" + "\n".join(seg_lines) + "\n"
    cfg_path = workspace / "lorom.cfg"
    cfg_path.write_text(cfg_text)
    return cfg_path


def write_snes_header(rom_data: bytearray, manifest: dict):
    """Write LoROM SNES internal header.

    Standard LoROM internal header layout (all offsets from $7FC0):
      $7FC0–$7FD4  21-byte game title (ASCII, space-padded)
      $7FD5        Map mode  (0x20 = LoROM, 0x30 = FastROM LoROM)
      $7FD6        Cartridge type
      $7FD7        ROM size  (1<<N KB)
      $7FD8        SRAM size (1<<N KB, 0 = none)
      $7FD9        Country / video standard
      $7FDA        Developer ID
      $7FDB        Version
      $7FDC–$7FDD  Checksum complement  (written separately)
      $7FDE–$7FDF  Checksum             (written separately)
    """
    title = Path(manifest.get("source_rom", "NESPORT")).stem.upper()[:21]
    title_bytes = title.encode("ascii", errors="replace").ljust(21, b" ")

    prg_size = manifest["prg_rom_size_bytes"]
    rom_size_code = 0
    sz = 1024
    while sz < prg_size + 32768:
        rom_size_code += 1
        sz <<= 1

    battery = manifest.get("battery_backed", False)
    rom_type = ROM_TYPE_ROM_SRAM if battery else ROM_TYPE_ROM_ONLY

    # Ensure rom_data is large enough to hold the header
    needed = SNES_HEADER_OFFSET_LOROM + 0x40
    if len(rom_data) < needed:
        rom_data.extend(b"\xFF" * (needed - len(rom_data)))

    o = SNES_HEADER_OFFSET_LOROM          # $7FC0
    rom_data[o:     o + 21] = title_bytes  # $7FC0–$7FD4: title
    rom_data[o + 21] = 0x20               # $7FD5: map mode (LoROM)
    rom_data[o + 22] = rom_type           # $7FD6: cartridge type
    rom_data[o + 23] = rom_size_code      # $7FD7: ROM size code
    rom_data[o + 24] = 0x00               # $7FD8: SRAM size (none)
    rom_data[o + 25] = COUNTRY_NTSC       # $7FD9: country
    rom_data[o + 26] = 0x00               # $7FDA: developer ID
    rom_data[o + 27] = 0x00               # $7FDB: version


def compute_checksum(rom_data: bytes) -> tuple[int, int]:
    checksum = sum(rom_data) & 0xFFFF
    complement = checksum ^ 0xFFFF
    return checksum, complement


def assemble_rom(workspace: Path, manifest: dict, output_dir: Path) -> Path:
    ca65, ld65 = check_toolchain()
    output_dir.mkdir(parents=True, exist_ok=True)

    bank_layout = json.loads((workspace / "bank_layout.json").read_text())
    master_asm  = generate_master_asm(workspace, bank_layout)
    lorom_cfg   = generate_lorom_cfg(workspace, bank_layout)

    obj_path = workspace / "master.o"
    sfc_path = output_dir / "output.sfc"

    # Assemble — run from workspace so .include paths resolve correctly
    print("[build_snes_rom] Assembling with ca65 ...")
    result = subprocess.run(
        [ca65, "--cpu", "65816", "-o", str(obj_path.resolve()), str(master_asm.resolve())],
        capture_output=True, text=True, cwd=str(workspace.resolve()),
    )
    if result.returncode != 0:
        print("[build_snes_rom] ca65 error:", file=sys.stderr)
        print(result.stderr, file=sys.stderr)
        sys.exit(1)

    # Link
    print("[build_snes_rom] Linking with ld65 ...")
    result = subprocess.run(
        [ld65, "-C", str(lorom_cfg.resolve()), "-o", str(sfc_path.resolve()), str(obj_path.resolve())],
        capture_output=True, text=True, cwd=str(workspace.resolve()),
    )
    if result.returncode != 0:
        print("[build_snes_rom] ld65 error:", file=sys.stderr)
        print(result.stderr, file=sys.stderr)
        sys.exit(1)

    # Post-process: embed CHR, write header, fix checksum
    rom_data = bytearray(sfc_path.read_bytes())

    chr_bin = workspace / "chr_snes.bin"
    if chr_bin.exists() and chr_bin.stat().st_size > 0:
        # CHR data goes into VRAM at load time; embed it in a dedicated ROM bank
        chr_data = chr_bin.read_bytes()
        # Append CHR data at end of ROM if space allows, then loader copies to VRAM
        rom_data.extend(chr_data)
        print(f"[build_snes_rom] Embedded {len(chr_data)} bytes of CHR data")

    write_snes_header(rom_data, manifest)
    # Zero checksum fields before summing so those bytes don't corrupt the result
    struct.pack_into("<HH", rom_data, SNES_CHECKSUM_OFFSET, 0x0000, 0x0000)
    checksum, complement = compute_checksum(rom_data)
    struct.pack_into("<HH", rom_data, SNES_CHECKSUM_OFFSET, complement, checksum)

    sfc_path.write_bytes(rom_data)
    print(f"[build_snes_rom] Output ROM: {sfc_path} ({len(rom_data)} bytes)")
    print(f"[build_snes_rom] Checksum: ${checksum:04X}  Complement: ${complement:04X}")

    return sfc_path


def main():
    parser = argparse.ArgumentParser(description="Assemble translated ASM into SNES ROM")
    parser.add_argument("--workspace", default="workspace")
    parser.add_argument("--output", default="output")
    args = parser.parse_args()

    workspace   = Path(args.workspace)
    output_dir  = Path(args.output)
    manifest    = json.loads((workspace / "rom_manifest.json").read_text())

    sfc_path = assemble_rom(workspace, manifest, output_dir)
    print(f"[build_snes_rom] Done: {sfc_path}")


if __name__ == "__main__":
    main()
