#!/usr/bin/env python3
"""
Stage 8: build_snes_rom.py
Assembles all translated .asm files into a final SNES LoROM .sfc using ca65/ld65.
Embeds CHR data, computes SNES checksum, and writes the build report.

Output: output/output.sfc, output/build_report.json
"""
import argparse
import json
import struct
import subprocess
import sys
import time
from pathlib import Path

SNES_HEADER_OFFSET_LOROM = 0x7FC0   # LoROM: internal header title starts at $7FC0
SNES_CHECKSUM_OFFSET     = 0x7FDC   # complement ($7FDC–$7FDD), checksum ($7FDE–$7FDF)

# SNES ROM type codes (FFCC)
ROM_TYPE_ROM_ONLY = 0x00
ROM_TYPE_ROM_SRAM = 0x02

# Country code: USA NTSC = $01
COUNTRY_NTSC = 0x01


def find_tool(name: str) -> str | None:
    """Find a CLI tool via 'which'."""
    result = subprocess.run(["which", name], capture_output=True, text=True)
    return result.stdout.strip() if result.returncode == 0 else None


def check_toolchain():
    ca65 = find_tool("ca65")
    ld65 = find_tool("ld65")
    if not ca65 or not ld65:
        print("ERROR: ca65/ld65 not found. Install with: brew install cc65", file=sys.stderr)
        sys.exit(1)
    return ca65, ld65


def generate_master_asm(workspace: Path, bank_layout: dict) -> Path:
    """Generate master.asm that .includes all translated bank files."""
    translated_dir = workspace / "translated"
    bank_files = sorted(translated_dir.glob("bank_*_65816.asm"))

    lines = [
        "; master.asm — auto-generated by build_snes_rom.py",
        ".setcpu \"65816\"",
        ".smart",
        "",
        '; System bank: PPU wrappers, mapper stubs, PPU init, SNES header',
        '.segment "BANK00"',
        '    .include "ppu_init.asm"',
        '    .include "ppu_wrappers.asm"',
        '    .include "mapper_stubs.asm"',
        "",
        "; --- Interrupt vector trampolines ---",
        "; SNES vectors must hold 16-bit addresses in bank $00.",
        "; These stubs live in BANK00 and JML (long-jump) to the actual handlers",
        "; which may be in any translated bank.",
        "NMI_TRAMPOLINE:",
        "    JML NMI_HANDLER",
        "IRQ_TRAMPOLINE:",
        "    JML IRQ_HANDLER",
        "RESET_TRAMPOLINE:",
        "    JML RESET_HANDLER",
        "",
    ]

    # Include translated PRG banks
    for bank_info in bank_layout.get("bank_map", []):
        snes_bank_int = int(bank_info["snes_bank"], 16)
        nes_bank = bank_info["nes_bank_num"]
        bank_file = f"bank_{nes_bank:02d}_65816.asm"
        seg_name = f"BANK{snes_bank_int:02X}"

        lines += [
            f'; Translated NES PRG bank {nes_bank} → SNES bank ${snes_bank_int:02X}',
            f'.segment "{seg_name}"',
            f'    .include "translated/{bank_file}"',
            "",
        ]

    # Audio stub (placeholder — SPC700 code assembled separately)
    audio_bank_int = int(bank_layout.get("audio_bank", "0x1E"), 16)
    audio_seg = f"BANK{audio_bank_int:02X}"
    lines += [
        '; SPC700 audio driver stub',
        f'.segment "{audio_seg}"',
        '    .res 512, $00',
        "",
    ]

    # Fallback stubs — must come BEFORE VECTORS so labels are defined.
    # Only assembled if translated code did not define the label.
    lines += [
        "; Fallback stubs for interrupt handlers",
        ".ifndef NMI_HANDLER",
        "NMI_HANDLER:",
        "    RTI",
        ".endif",
        ".ifndef IRQ_HANDLER",
        "IRQ_HANDLER:",
        "    RTI",
        ".endif",
        ".ifndef RESET_HANDLER",
        "RESET_HANDLER:",
        "    JSR SNES_PPU_INIT",
        "    BRA *",
        ".endif",
        "",
    ]

    # SNES interrupt vectors (LoROM: $FFE0–$FFFF within bank $00)
    # The VECTORS segment is placed at $FFE0 inside BANK00 by the linker config.
    # 32 bytes = 16 words covering $FFE0–$FFFF. No .org needed.
    lines += [
        '; SNES interrupt vectors ($FFE0–$FFFF)',
        '.segment "VECTORS"',
        '    .word $0000              ; $FFE0: (unused)',
        '    .word $0000              ; $FFE2: (unused)',
        '    .word $0000              ; $FFE4: COP (native)',
        '    .word $0000              ; $FFE6: BRK (native)',
        '    .word $0000              ; $FFE8: ABORT (native)',
        '    .word NMI_TRAMPOLINE     ; $FFEA: NMI (native)',
        '    .word $0000              ; $FFEC: (unused)',
        '    .word IRQ_TRAMPOLINE     ; $FFEE: IRQ (native)',
        '    .word $0000              ; $FFF0: (unused)',
        '    .word $0000              ; $FFF2: (unused)',
        '    .word $0000              ; $FFF4: COP (emulation)',
        '    .word $0000              ; $FFF6: (unused)',
        '    .word $0000              ; $FFF8: ABORT (emulation)',
        '    .word NMI_TRAMPOLINE     ; $FFFA: NMI (emulation)',
        '    .word RESET_TRAMPOLINE   ; $FFFC: RESET',
        '    .word IRQ_TRAMPOLINE     ; $FFFE: IRQ/BRK (emulation)',
    ]

    master_path = workspace / "master.asm"
    master_path.write_text("\n".join(lines))
    return master_path


def generate_lorom_cfg(workspace: Path, bank_layout: dict) -> Path:
    """Generate ld65 LoROM linker configuration."""
    segments = []
    bank_map = bank_layout.get("bank_map", [])

    # Add system + translated banks
    all_banks = [{"snes_bank": "0x00", "seg": "BANK00", "start": 0x008000, "size": 0x8000}]
    for bi in bank_map:
        n = int(bi["snes_bank"], 16)
        seg = f"BANK{n:02X}"
        start = n * 0x10000 + 0x8000
        all_banks.append({"snes_bank": bi["snes_bank"], "seg": seg, "start": start, "size": 0x8000})

    # Audio bank
    audio_bank_int = int(bank_layout.get("audio_bank", "0x1E"), 16)
    all_banks.append({
        "snes_bank": f"0x{audio_bank_int:02X}",
        "seg": f"BANK{audio_bank_int:02X}",
        "start": audio_bank_int * 0x10000 + 0x8000,
        "size": 0x8000,
    })

    memory_lines = ["MEMORY {"]
    # ZEROPAGE maps to SNES Direct Page (WRAM at $0000–$00FF, not in ROM file)
    memory_lines.append("    ZEROPAGE: start = $0000, size = $0100, type = rw, define = yes;")
    seg_lines    = ["SEGMENTS {"]
    seg_lines.append("    ZEROPAGE: load = ZEROPAGE, type = zp;")

    for b in all_banks:
        seg = b["seg"]
        start = b["start"]
        size = b["size"]
        memory_lines.append(
            f"    {seg}: start = ${start:06X}, size = ${size:04X}, "
            f"fill = yes, fillval = $FF, file = %O;"
        )
        seg_lines.append(f"    {seg}: load = {seg}, type = ro;")

    # VECTORS segment lives inside BANK00 at CPU $FFE0 (file offset $7FE0)
    # NOT a separate memory area — placed within BANK00 using start address
    seg_lines.append("    VECTORS: load = BANK00, type = ro, start = $FFE0;")

    memory_lines.append("}")
    seg_lines.append("}")

    cfg_text = "\n".join(memory_lines) + "\n\n" + "\n".join(seg_lines) + "\n"
    cfg_path = workspace / "lorom.cfg"
    cfg_path.write_text(cfg_text)
    return cfg_path


def write_snes_header(rom_data: bytearray, manifest: dict):
    """Write LoROM SNES internal header.

    Standard LoROM internal header layout (all offsets from $7FC0):
      $7FC0–$7FD4  21-byte game title (ASCII, space-padded)
      $7FD5        Map mode  (0x20 = LoROM, 0x30 = FastROM LoROM)
      $7FD6        Cartridge type
      $7FD7        ROM size  (1<<N KB)
      $7FD8        SRAM size (1<<N KB, 0 = none)
      $7FD9        Country / video standard
      $7FDA        Developer ID
      $7FDB        Version
      $7FDC–$7FDD  Checksum complement  (written separately)
      $7FDE–$7FDF  Checksum             (written separately)
    """
    title = Path(manifest.get("source_rom", "NESPORT")).stem.upper()[:21]
    title_bytes = title.encode("ascii", errors="replace").ljust(21, b" ")

    battery = manifest.get("battery_backed", False)
    rom_type = ROM_TYPE_ROM_SRAM if battery else ROM_TYPE_ROM_ONLY

    # ROM size code is based on the actual total ROM size (set after padding)
    # N means 1<<N KB; computed from len(rom_data) which must already be
    # padded to a power of 2 before calling this function.
    total_kb = len(rom_data) // 1024
    rom_size_code = max(total_kb.bit_length() - 1, 0) if total_kb > 0 else 0
    # Verify: 1 << rom_size_code should equal total_kb for power-of-2 sizes
    if (1 << rom_size_code) < total_kb:
        rom_size_code += 1

    # Ensure rom_data is large enough to hold the header
    needed = SNES_HEADER_OFFSET_LOROM + 0x40
    if len(rom_data) < needed:
        rom_data.extend(b"\xFF" * (needed - len(rom_data)))

    o = SNES_HEADER_OFFSET_LOROM          # $7FC0
    rom_data[o:     o + 21] = title_bytes  # $7FC0–$7FD4: title
    rom_data[o + 21] = 0x20               # $7FD5: map mode (LoROM)
    rom_data[o + 22] = rom_type           # $7FD6: cartridge type
    rom_data[o + 23] = rom_size_code      # $7FD7: ROM size code
    rom_data[o + 24] = 0x00               # $7FD8: SRAM size (none)
    rom_data[o + 25] = COUNTRY_NTSC       # $7FD9: country
    rom_data[o + 26] = 0x00               # $7FDA: developer ID
    rom_data[o + 27] = 0x00               # $7FDB: version


def compute_checksum(rom_data: bytes) -> tuple[int, int]:
    checksum = sum(rom_data) & 0xFFFF
    complement = checksum ^ 0xFFFF
    return checksum, complement


def assemble_rom(workspace: Path, manifest: dict, output_dir: Path) -> Path:
    ca65, ld65 = check_toolchain()
    output_dir.mkdir(parents=True, exist_ok=True)

    bank_layout = json.loads((workspace / "bank_layout.json").read_text())
    master_asm  = generate_master_asm(workspace, bank_layout)
    lorom_cfg   = generate_lorom_cfg(workspace, bank_layout)

    obj_path = workspace / "master.o"
    sfc_path = output_dir / "output.sfc"

    # Assemble — run from workspace so .include paths resolve correctly
    print("[build_snes_rom] Assembling with ca65 ...")
    result = subprocess.run(
        [ca65, "--cpu", "65816", "-o", str(obj_path.resolve()), str(master_asm.resolve())],
        capture_output=True, text=True, cwd=str(workspace.resolve()),
    )
    if result.returncode != 0:
        print("[build_snes_rom] ca65 error:", file=sys.stderr)
        print(result.stderr, file=sys.stderr)
        sys.exit(1)

    # Link
    print("[build_snes_rom] Linking with ld65 ...")
    result = subprocess.run(
        [ld65, "-C", str(lorom_cfg.resolve()), "-o", str(sfc_path.resolve()), str(obj_path.resolve())],
        capture_output=True, text=True, cwd=str(workspace.resolve()),
    )
    if result.returncode != 0:
        print("[build_snes_rom] ld65 error:", file=sys.stderr)
        print(result.stderr, file=sys.stderr)
        sys.exit(1)

    # Post-process: embed CHR, write header, fix checksum
    rom_data = bytearray(sfc_path.read_bytes())

    chr_bin = workspace / "chr_snes.bin"
    if chr_bin.exists() and chr_bin.stat().st_size > 0:
        # CHR data goes into VRAM at load time; embed it in a dedicated ROM bank
        chr_data = chr_bin.read_bytes()
        # Append CHR data at end of ROM if space allows, then loader copies to VRAM
        rom_data.extend(chr_data)
        print(f"[build_snes_rom] Embedded {len(chr_data)} bytes of CHR data")

    # Pad ROM to next power-of-2 size (SNES requirement)
    raw_size = len(rom_data)
    padded_size = 1
    while padded_size < raw_size:
        padded_size <<= 1
    if padded_size > raw_size:
        rom_data.extend(b"\xFF" * (padded_size - raw_size))
        print(f"[build_snes_rom] Padded ROM from {raw_size} to {padded_size} bytes")

    write_snes_header(rom_data, manifest)
    # SNES checksum: set complement=$FFFF, checksum=$0000, then sum all bytes
    struct.pack_into("<HH", rom_data, SNES_CHECKSUM_OFFSET, 0xFFFF, 0x0000)
    checksum, complement = compute_checksum(rom_data)
    struct.pack_into("<HH", rom_data, SNES_CHECKSUM_OFFSET, complement, checksum)

    sfc_path.write_bytes(rom_data)
    print(f"[build_snes_rom] Output ROM: {sfc_path} ({len(rom_data)} bytes)")
    print(f"[build_snes_rom] Checksum: ${checksum:04X}  Complement: ${complement:04X}")

    return sfc_path


def main():
    parser = argparse.ArgumentParser(description="Assemble translated ASM into SNES ROM")
    parser.add_argument("--workspace", default="workspace")
    parser.add_argument("--output", default="output")
    args = parser.parse_args()

    workspace   = Path(args.workspace)
    output_dir  = Path(args.output)
    manifest    = json.loads((workspace / "rom_manifest.json").read_text())

    sfc_path = assemble_rom(workspace, manifest, output_dir)
    print(f"[build_snes_rom] Done: {sfc_path}")


if __name__ == "__main__":
    main()
