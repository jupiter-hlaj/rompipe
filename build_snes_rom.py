#!/usr/bin/env python3
"""
Stage 8: build_snes_rom.py
Assembles all translated .asm files into a final SNES LoROM .sfc using ca65/ld65.
Embeds CHR data, computes SNES checksum, and writes the build report.

Output: output/output.sfc, output/build_report.json
"""
import argparse
import json
import struct
import subprocess
import sys
import time
from pathlib import Path

SNES_HEADER_OFFSET_LOROM = 0x7FB0   # LoROM: header at bank $00, file offset $7FB0
SNES_CHECKSUM_OFFSET     = 0x7FDC   # complement ($7FDC–$7FDD), checksum ($7FDE–$7FDF)

# SNES ROM type codes (FFCC)
ROM_TYPE_ROM_ONLY = 0x00
ROM_TYPE_ROM_SRAM = 0x02

# Country code: USA NTSC = $01
COUNTRY_NTSC = 0x01


def find_tool(name: str) -> str | None:
    """Find a CLI tool via 'which'."""
    result = subprocess.run(["which", name], capture_output=True, text=True)
    return result.stdout.strip() if result.returncode == 0 else None


def check_toolchain():
    ca65 = find_tool("ca65")
    ld65 = find_tool("ld65")
    if not ca65 or not ld65:
        print("ERROR: ca65/ld65 not found. Install with: brew install cc65", file=sys.stderr)
        sys.exit(1)
    return ca65, ld65


def generate_master_asm(workspace: Path, bank_layout: dict) -> Path:
    """Generate master.asm that .includes all translated bank files."""
    translated_dir = workspace / "translated"
    bank_files = sorted(translated_dir.glob("bank_*_65816.asm"))

    lines = [
        "; master.asm — auto-generated by build_snes_rom.py",
        ".setcpu \"65816\"",
        ".smart",
        "",
        '; System bank: PPU wrappers, mapper stubs, PPU init, SNES header',
        '.segment "BANK00"',
        ".org $008000",
        '    .include "../ppu_init.asm"',
        '    .include "../ppu_wrappers.asm"',
        '    .include "../mapper_stubs.asm"',
        "",
    ]

    # Include translated PRG banks
    for bank_info in bank_layout.get("bank_map", []):
        snes_bank_int = int(bank_info["snes_bank"], 16)
        nes_bank = bank_info["nes_bank_num"]
        bank_file = f"bank_{nes_bank:02d}_65816.asm"
        seg_name = f"BANK{snes_bank_int:02X}"
        org_addr = snes_bank_int * 0x10000 + 0x8000

        lines += [
            f'; Translated NES PRG bank {nes_bank} → SNES bank ${snes_bank_int:02X}',
            f'.segment "{seg_name}"',
            f".org ${org_addr:06X}",
            f'    .include "../translated/{bank_file}"',
            "",
        ]

    # Audio bank
    audio_bank_str = bank_layout.get("audio_bank", "0x1E")
    audio_bank_int = int(audio_bank_str, 16)
    audio_org = audio_bank_int * 0x10000 + 0x8000
    lines += [
        f'; SPC700 audio driver',
        f'.segment "BANK{audio_bank_int:02X}"',
        f".org ${audio_org:06X}",
        '    .include "../audio/spc_driver.asm"',
        "",
    ]

    # SNES interrupt vectors (LoROM: fixed in last bank, $FFXX)
    lines += [
        '; SNES interrupt vectors',
        '.segment "VECTORS"',
        ".org $00FFE4",
        '    .word $0000         ; COP',
        '    .word $0000         ; BRK',
        '    .word $0000         ; ABORT',
        '    .word NMI_HANDLER   ; NMI — must be defined in translated code',
        '    .word $0000         ; (unused RESET in native mode)',
        '    .word IRQ_HANDLER   ; IRQ',
        '.org $00FFF4',
        '    .word $0000         ; COP (emulation)',
        '    .word $0000',
        '    .word $0000         ; ABORT (emulation)',
        '    .word NMI_HANDLER   ; NMI (emulation)',
        '    .word RESET_HANDLER ; RESET — must be defined in translated code',
        '    .word IRQ_HANDLER   ; IRQ/BRK (emulation)',
        "",
        "; Fallback stubs (overridden if translated code defines these labels)",
        ".ifndef NMI_HANDLER",
        "NMI_HANDLER:",
        "    RTI",
        ".endif",
        ".ifndef IRQ_HANDLER",
        "IRQ_HANDLER:",
        "    RTI",
        ".endif",
        ".ifndef RESET_HANDLER",
        "RESET_HANDLER:",
        "    JSR SNES_PPU_INIT",
        "    BRA *",
        ".endif",
    ]

    master_path = workspace / "master.asm"
    master_path.write_text("\n".join(lines))
    return master_path


def generate_lorom_cfg(workspace: Path, bank_layout: dict) -> Path:
    """Generate ld65 LoROM linker configuration."""
    segments = []
    bank_map = bank_layout.get("bank_map", [])

    # Add system + translated banks
    all_banks = [{"snes_bank": "0x00", "seg": "BANK00", "start": 0x008000, "size": 0x8000}]
    for bi in bank_map:
        n = int(bi["snes_bank"], 16)
        seg = f"BANK{n:02X}"
        start = n * 0x10000 + 0x8000
        all_banks.append({"snes_bank": bi["snes_bank"], "seg": seg, "start": start, "size": 0x8000})

    # Audio bank
    audio_bank_int = int(bank_layout.get("audio_bank", "0x1E"), 16)
    all_banks.append({
        "snes_bank": f"0x{audio_bank_int:02X}",
        "seg": f"BANK{audio_bank_int:02X}",
        "start": audio_bank_int * 0x10000 + 0x8000,
        "size": 0x8000,
    })

    # Vectors in bank $00 at $FFxx
    all_banks.append({
        "snes_bank": "0x00",
        "seg": "VECTORS",
        "start": 0x00FFE0,
        "size": 0x20,
    })

    memory_lines = ["MEMORY {"]
    seg_lines    = ["SEGMENTS {"]

    for b in all_banks:
        seg = b["seg"]
        start = b["start"]
        size = b["size"]
        # Compute file offset for LoROM: bank*$8000 + (addr - $8000)
        bank_num = start >> 16
        file_offset = bank_num * 0x8000 + (start & 0x7FFF)
        memory_lines.append(
            f"    {seg}: start = ${start:06X}, size = ${size:04X}, "
            f"fill = yes, fillval = $FF, file = %O;"
        )
        seg_lines.append(f"    {seg}: load = {seg}, type = ro, offset = ${file_offset:06X};")

    memory_lines.append("}")
    seg_lines.append("}")

    cfg_text = "\n".join(memory_lines) + "\n\n" + "\n".join(seg_lines) + "\n"
    cfg_path = workspace / "lorom.cfg"
    cfg_path.write_text(cfg_text)
    return cfg_path


def write_snes_header(rom_data: bytearray, manifest: dict):
    """Write LoROM SNES internal header at file offset $7FB0."""
    title = Path(manifest.get("source_rom", "NESPORT")).stem.upper()[:21]
    title_bytes = title.encode("ascii", errors="replace").ljust(21, b" ")

    prg_size = manifest["prg_rom_size_bytes"]
    rom_size_code = 0
    sz = 1024
    while sz < prg_size + 32768:
        rom_size_code += 1
        sz <<= 1

    battery = manifest.get("battery_backed", False)
    rom_type = ROM_TYPE_ROM_SRAM if battery else ROM_TYPE_ROM_ONLY

    # Ensure rom_data is large enough
    needed = SNES_HEADER_OFFSET_LOROM + 0x50
    if len(rom_data) < needed:
        rom_data.extend(b"\xFF" * (needed - len(rom_data)))

    o = SNES_HEADER_OFFSET_LOROM
    rom_data[o: o + 2] = b"NN"           # maker code
    rom_data[o + 2: o + 6] = b"PORT"     # game code
    rom_data[o + 6: o + 9] = b"\x00" * 3
    rom_data[o + 9]  = 0x00              # expansion RAM size
    rom_data[o + 10] = 0x00              # special version
    rom_data[o + 11] = 0x00              # cart sub-type
    rom_data[o + 12: o + 33] = title_bytes  # 21-byte title
    rom_data[o + 33] = 0x20              # ROM makeup: LoROM, FastROM
    rom_data[o + 34] = rom_type          # ROM type
    rom_data[o + 35] = rom_size_code     # ROM size
    rom_data[o + 36] = 0x00              # SRAM size
    rom_data[o + 37] = COUNTRY_NTSC      # country
    rom_data[o + 38] = 0x33              # developer ID ($33 = extended header)
    rom_data[o + 39] = 0x00              # version


def compute_checksum(rom_data: bytes) -> tuple[int, int]:
    checksum = sum(rom_data) & 0xFFFF
    complement = checksum ^ 0xFFFF
    return checksum, complement


def assemble_rom(workspace: Path, manifest: dict, output_dir: Path) -> Path:
    ca65, ld65 = check_toolchain()
    output_dir.mkdir(parents=True, exist_ok=True)

    bank_layout = json.loads((workspace / "bank_layout.json").read_text())
    master_asm  = generate_master_asm(workspace, bank_layout)
    lorom_cfg   = generate_lorom_cfg(workspace, bank_layout)

    obj_path = workspace / "master.o"
    sfc_path = output_dir / "output.sfc"

    # Assemble
    print("[build_snes_rom] Assembling with ca65 ...")
    result = subprocess.run(
        [ca65, "--cpu", "65816", "-o", str(obj_path), str(master_asm)],
        capture_output=True, text=True, cwd=str(workspace),
    )
    if result.returncode != 0:
        print("[build_snes_rom] ca65 error:", file=sys.stderr)
        print(result.stderr, file=sys.stderr)
        sys.exit(1)

    # Link
    print("[build_snes_rom] Linking with ld65 ...")
    result = subprocess.run(
        [ld65, "-C", str(lorom_cfg), "-o", str(sfc_path), str(obj_path)],
        capture_output=True, text=True, cwd=str(workspace),
    )
    if result.returncode != 0:
        print("[build_snes_rom] ld65 error:", file=sys.stderr)
        print(result.stderr, file=sys.stderr)
        sys.exit(1)

    # Post-process: embed CHR, write header, fix checksum
    rom_data = bytearray(sfc_path.read_bytes())

    chr_bin = workspace / "chr_snes.bin"
    if chr_bin.exists() and chr_bin.stat().st_size > 0:
        # CHR data goes into VRAM at load time; embed it in a dedicated ROM bank
        chr_data = chr_bin.read_bytes()
        # Append CHR data at end of ROM if space allows, then loader copies to VRAM
        rom_data.extend(chr_data)
        print(f"[build_snes_rom] Embedded {len(chr_data)} bytes of CHR data")

    write_snes_header(rom_data, manifest)
    checksum, complement = compute_checksum(rom_data)
    struct.pack_into("<HH", rom_data, SNES_CHECKSUM_OFFSET, complement, checksum)

    sfc_path.write_bytes(rom_data)
    print(f"[build_snes_rom] Output ROM: {sfc_path} ({len(rom_data)} bytes)")
    print(f"[build_snes_rom] Checksum: ${checksum:04X}  Complement: ${complement:04X}")

    return sfc_path


def main():
    parser = argparse.ArgumentParser(description="Assemble translated ASM into SNES ROM")
    parser.add_argument("--workspace", default="workspace")
    parser.add_argument("--output", default="output")
    args = parser.parse_args()

    workspace   = Path(args.workspace)
    output_dir  = Path(args.output)
    manifest    = json.loads((workspace / "rom_manifest.json").read_text())

    sfc_path = assemble_rom(workspace, manifest, output_dir)
    print(f"[build_snes_rom] Done: {sfc_path}")


if __name__ == "__main__":
    main()
