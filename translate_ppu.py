#!/usr/bin/env python3
"""
Stage 4: translate_ppu.py
Generates SNES PPU wrapper subroutines (ca65 ASM) that intercept all NES
PPU register writes ($2000–$2007, $4014) and translate them to the equivalent
SNES PPU register operations.

Output: workspace/ppu_wrappers.asm, workspace/ppu_init.asm
"""
import argparse
import json
import sys
from pathlib import Path

# SNES PPU register addresses
SNES_INIDISP  = 0x2100
SNES_OBSEL    = 0x2101
SNES_OAMADDL  = 0x2102
SNES_OAMADDH  = 0x2103
SNES_OAMDATA  = 0x2104
SNES_BGMODE   = 0x2105
SNES_MOSAIC   = 0x2106
SNES_BG1SC    = 0x2107
SNES_BG12NBA  = 0x210B
SNES_BG1HOFS  = 0x210D
SNES_BG1VOFS  = 0x210E
SNES_VMAIN    = 0x2115
SNES_VMADDL   = 0x2116
SNES_VMADDH   = 0x2117
SNES_VMDATAL  = 0x2118
SNES_VMDATAH  = 0x2119
SNES_CGADD    = 0x2121
SNES_CGDATA   = 0x2122
SNES_TM       = 0x212C
SNES_CGADSUB  = 0x2130
SNES_NMITIMEN = 0x4200
SNES_DMAP0    = 0x4300
SNES_BBAD0    = 0x4301
SNES_A1T0L    = 0x4302
SNES_A1T0H    = 0x4303
SNES_A1T0B    = 0x4304
SNES_DAS0L    = 0x4305
SNES_DAS0H    = 0x4306
SNES_MDMAEN   = 0x420B
SNES_RDNMI    = 0x4210
SNES_STAT77   = 0x213E


PPU_WRAPPERS_ASM = """\
; =============================================================================
; ppu_wrappers.asm  —  NES PPU register emulation for SNES
; Auto-generated by translate_ppu.py
; All wrappers expect value in A (8-bit), preserve X and Y.
; =============================================================================

.setcpu "65816"
.smart

; Shadow registers in WRAM (Zero Page / Direct Page)
.segment "ZEROPAGE"
NES_PPUCTRL:    .res 1   ; shadow of $2000
NES_PPUMASK:    .res 1   ; shadow of $2001
PPU_ADDR_LATCH: .res 1   ; 0=expecting high byte, 1=expecting low byte
PPU_ADDR_HIGH:  .res 1   ; latched high byte for $2006 protocol
SCR_LATCH:      .res 1   ; 0=X scroll next, 1=Y scroll next
SCROLL_X:       .res 1   ; latched horizontal scroll
TM_SHADOW:      .res 1   ; main screen designation shadow

.segment "BANK00"

; -----------------------------------------------------------------------------
; PPU_CTRL_WRITE  ($2000)
; Bits: NMI_EN | SPRITE_SZ | BG_TBL | SP_TBL | VRAM_INC | NAMETABLE_SEL(2)
; -----------------------------------------------------------------------------
.proc PPU_CTRL_WRITE
    STA NES_PPUCTRL

    ; ---- NMI enable (bit 7) ----
    AND #$80
    BEQ @nmi_off
    LDA #$81            ; V-blank NMI + auto-joypad
    STA $4200           ; NMITIMEN
    BRA @nmi_done
@nmi_off:
    LDA #$01
    STA $4200
@nmi_done:

    ; ---- VRAM address increment (bit 2: 0=+1 row, 1=+32 column) ----
    LDA NES_PPUCTRL
    AND #$04
    BEQ @inc1
    LDA #$80            ; VMAIN: increment by 32 (column mode)
    STA $2115
    BRA @inc_done
@inc1:
    LDA #$00            ; VMAIN: increment by 1 (row mode)
    STA $2115
@inc_done:

    ; ---- Sprite size (bit 5: 0=8x8, 1=8x16) ----
    LDA NES_PPUCTRL
    AND #$20
    BEQ @small_sprites
    LDA #$42            ; OBSEL: sprites from $4000, 16px height
    STA $2101
    BRA @sprite_done
@small_sprites:
    LDA #$02            ; OBSEL: sprites from $4000, 8px height
    STA $2101
@sprite_done:
    RTS
.endproc

; -----------------------------------------------------------------------------
; PPU_MASK_WRITE  ($2001)
; Bits: BGR_EMPH(3) | SPR_ENABLE | BG_ENABLE | SPR_CLIP | BG_CLIP | GREYSCALE
; -----------------------------------------------------------------------------
.proc PPU_MASK_WRITE
    STA NES_PPUMASK
    LDA #$00
    STA TM_SHADOW

    ; BG enable (bit 1)
    LDA NES_PPUMASK
    AND #$02
    BEQ @no_bg
    LDA TM_SHADOW
    ORA #$01            ; enable BG1 on main screen
    STA TM_SHADOW
@no_bg:
    ; Sprite enable (bit 4)
    LDA NES_PPUMASK
    AND #$10
    BEQ @no_spr
    LDA TM_SHADOW
    ORA #$10            ; enable OBJ on main screen
    STA TM_SHADOW
@no_spr:
    LDA TM_SHADOW
    STA $212C           ; TM: main screen designation
    RTS
.endproc

; -----------------------------------------------------------------------------
; PPU_SCROLL_WRITE  ($2005)
; Two-write protocol: first write = X scroll, second = Y scroll
; -----------------------------------------------------------------------------
.proc PPU_SCROLL_WRITE
    LDX SCR_LATCH
    BNE @y_scroll
    STA SCROLL_X
    STA $210D           ; BG1HOFS low byte
    STZ $210D           ; BG1HOFS high byte (0)
    LDA #$01
    STA SCR_LATCH
    RTS
@y_scroll:
    STA $210E           ; BG1VOFS low byte
    STZ $210E           ; BG1VOFS high byte (0)
    STZ SCR_LATCH
    RTS
.endproc

; -----------------------------------------------------------------------------
; PPU_ADDR_WRITE  ($2006)
; Two-write protocol: high byte first, then low byte → sets VRAM address
; -----------------------------------------------------------------------------
.proc PPU_ADDR_WRITE
    LDX PPU_ADDR_LATCH
    BNE @low_byte
    STA PPU_ADDR_HIGH
    LDA #$01
    STA PPU_ADDR_LATCH
    RTS
@low_byte:
    STA $2116           ; VMADDL
    LDA PPU_ADDR_HIGH
    STA $2117           ; VMADDH
    STZ PPU_ADDR_LATCH
    RTS
.endproc

; -----------------------------------------------------------------------------
; PPU_DATA_WRITE  ($2007)
; Write one byte to VRAM at current address (auto-increments per VMAIN)
; -----------------------------------------------------------------------------
.proc PPU_DATA_WRITE
    STA $2118           ; VMDATAL
    STZ $2119           ; VMDATAH (high byte = 0 for byte writes)
    RTS
.endproc

; -----------------------------------------------------------------------------
; PPU_DATA_READ  ($2007 read)
; Read one byte from VRAM at current address
; Returns value in A
; -----------------------------------------------------------------------------
.proc PPU_DATA_READ
    LDA $2139           ; VMDATALREAD (low byte readback)
    RTS
.endproc

; -----------------------------------------------------------------------------
; PPU_STATUS_READ  ($2002 read)
; Returns NES-style status byte:
;   bit 7 = V-blank (from RDNMI bit 7)
;   bit 6 = sprite-0 hit (from STAT77 bit 6)
;   bits 0-4 = open bus (0)
; -----------------------------------------------------------------------------
.proc PPU_STATUS_READ
    LDA #$00
    LDX $4210           ; RDNMI: bit 7 = vblank occurred
    TXA
    AND #$80
    STA $00             ; temp
    LDA $213E           ; STAT77: bit 6 = sprite overflow/hit
    AND #$40
    ORA $00
    ; Clear scroll latch and addr latch (NES behavior on $2002 read)
    STZ PPU_ADDR_LATCH
    STZ SCR_LATCH
    RTS
.endproc

; -----------------------------------------------------------------------------
; OAM_ADDR_WRITE  ($2003)
; Set OAM address for subsequent writes
; -----------------------------------------------------------------------------
.proc OAM_ADDR_WRITE
    STA $2102           ; OAMADDL
    STZ $2103           ; OAMADDH
    RTS
.endproc

; -----------------------------------------------------------------------------
; OAM_DATA_WRITE  ($2004)
; Write one byte to OAM at current address
; -----------------------------------------------------------------------------
.proc OAM_DATA_WRITE
    STA $2104           ; OAMDATA
    RTS
.endproc

; -----------------------------------------------------------------------------
; OAM_DMA_TRIGGER  ($4014)
; A = source page number (source address = A * $100 in CPU bank $00 / WRAM)
; Triggers SNES DMA channel 0 to copy 256 bytes to OAM
; -----------------------------------------------------------------------------
.proc OAM_DMA_TRIGGER
    ; Source: A * $100 (page in WRAM)
    STA $4303           ; A1T0H (source high byte = page)
    STZ $4302           ; A1T0L (source low byte = 0)
    STZ $4304           ; A1T0B (source bank = $00 = WRAM mirror)
    LDA #$04            ; dest = $2104 (OAMDATA)
    STA $4301           ; BBAD0
    LDA #$00            ; transfer mode: 1 byte, fixed dest, increment src
    STA $4300           ; DMAP0
    LDA #$00            ; transfer size low = 256
    STA $4305           ; DAS0L
    LDA #$01            ; transfer size high
    STA $4306           ; DAS0H
    LDA #$01            ; enable DMA channel 0
    STA $420B           ; MDMAEN
    RTS
.endproc

; -----------------------------------------------------------------------------
; JOYPAD1_READ  ($4016)
; Returns: A = serial controller bit from port 1
; Called once per bit in the polling loop (strobe done separately via STX $4016)
; -----------------------------------------------------------------------------
.proc JOYPAD1_READ
    LDA $4016
    RTS
.endproc

; -----------------------------------------------------------------------------
; JOYPAD2_READ  ($4017)
; Returns: A = serial controller bit from port 2
; -----------------------------------------------------------------------------
.proc JOYPAD2_READ
    LDA $4017
    RTS
.endproc
"""

PPU_INIT_ASM = """\
; =============================================================================
; ppu_init.asm  —  SNES PPU initialization sequence
; Call once from the translated RESET handler before enabling NMI.
; =============================================================================

.setcpu "65816"
.smart

.segment "BANK00"

.proc SNES_PPU_INIT
    ; Force blank during init
    LDA #$8F
    STA $2100           ; INIDISP: forced blank, full brightness

    ; BG Mode 1: two 4bpp BG layers + one 2bpp BG
    LDA #$01
    STA $2105           ; BGMODE

    ; BG1 tilemap: VRAM $6000, 32x32 tiles (single screen)
    LDA #$60
    STA $2107           ; BG1SC: base=$6000>>9=0x30 -> actually addr>>9 for 32x32
    ; ($6000 >> 9) = $30, then shift left 2 = $C0 | 0 (no flip) = $C0
    ; For BG1SC: bits 7-2 = tilemap base >> 9, bits 1-0 = size (00=32x32)
    LDA #$C0
    STA $2107           ; BG1SC

    ; BG1 chr data at VRAM $0000 (4bpp tiles start at $0000)
    LDA #$00
    STA $210B           ; BG12NBA

    ; Sprite chr data at VRAM $4000
    LDA #$02            ; OBSEL: sprite table at $4000, 8x8 sprites
    STA $2101

    ; Clear scroll latches
    STZ $210D           ; BG1HOFS = 0
    STZ $210D
    STZ $210E           ; BG1VOFS = 0
    STZ $210E

    ; Enable BG1 + OBJ on main screen
    LDA #$11
    STA $212C           ; TM

    ; VRAM increment mode: increment by 1 after $2118 write
    LDA #$00
    STA $2115           ; VMAIN

    ; Enable NMI + auto-joypad
    LDA #$81
    STA $4200           ; NMITIMEN

    ; Disable forced blank — display on
    LDA #$0F
    STA $2100           ; INIDISP: no forced blank, full brightness

    RTS
.endproc
"""


def generate_ppu_files(workspace: Path):
    workspace.mkdir(parents=True, exist_ok=True)

    wrappers_path = workspace / "ppu_wrappers.asm"
    init_path     = workspace / "ppu_init.asm"

    wrappers_path.write_text(PPU_WRAPPERS_ASM)
    init_path.write_text(PPU_INIT_ASM)

    print(f"[translate_ppu] Written: {wrappers_path}")
    print(f"[translate_ppu] Written: {init_path}")
    print("[translate_ppu] Wrappers: PPU_CTRL_WRITE, PPU_MASK_WRITE, PPU_SCROLL_WRITE, "
          "PPU_ADDR_WRITE, PPU_DATA_WRITE, PPU_DATA_READ, PPU_STATUS_READ, "
          "OAM_ADDR_WRITE, OAM_DATA_WRITE, OAM_DMA_TRIGGER, "
          "JOYPAD1_READ, JOYPAD2_READ")


def main():
    parser = argparse.ArgumentParser(description="Generate SNES PPU wrapper subroutines")
    parser.add_argument("--workspace", default="workspace")
    args = parser.parse_args()

    workspace = Path(args.workspace)
    if not (workspace / "rom_manifest.json").exists():
        print("ERROR: rom_manifest.json not found — run parse_rom.py first", file=sys.stderr)
        sys.exit(1)

    generate_ppu_files(workspace)


if __name__ == "__main__":
    main()
